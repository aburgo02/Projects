Title         : OpSem Theory
Subtitle      : COMP105 Fall 2015
Author        : Andrew Burgos

Comment: These parameters govern typesetting of code and formulas
~Pre        : css-padding-left=1em
~Math-Inline: input=mathpre

[TITLE]

<!-- MathDefs allows us to define some useful commands for formatting
     inference rules -->

~ MathDefs
\newcommand{\state}[1]{\langle #1 \rangle}
\newcommand{\inference}[2]{\dfrac{#1}{#2}}
\newcommand{\yields}[0]{\Downarrow}
~

## Problem 16 {-}

### (a) Awk-like semantics {-}
Unbound

$x \notin @dom \rho  \\ x \notin @dom \xi$ 

----
$\state{VAR(x), \xi, \phi, \rho} \yields \state{0, \xi (x -> 0), \phi, \rho}$


Global

$x \notin @dom \rho$  
$\state{e, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'} $

----
$\state{SET(x,e) \xi, \phi, \rho} \yields \state{@v, \xi' (x -> v), \phi, \rho'}$

### (b) Icon-like semantics {-}

Unbound

$x \notin @dom \rho  \\ x \notin @dom \xi$ 

----
$\state{VAR(x), \xi, \phi, \rho} \yields \state{0, \xi, \phi, \rho (x -> 0)}$



Formal

$x \notin @dom \xi    \state{e, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'} $

----
$\state{SET(x,e) \xi, \phi, \rho} \yields \state{@v, \xi', \phi, \rho' (x -> v)}$


### (c) Which do you prefer and why? {-}
Icons method of implementation is my preferred method. Awk's method seems like a risk when dealing with extensive amounts of code because of the likely scenario that there will be conflicting unbound names.

## Problem 13 {-}

$(begin(set x 3) x)            \rho(x) = 99$

$\state{LIT 3, \xi, \phi, \rho} \yields \state{3, \xi, \phi, \rho}$

$x \in @dom \rho   (x -> 3)$ - Formal Var

$x \in @dom \rho$  - Formal Assign

Formal Assign - $\state{SET (x, LIT 3), \xi, \phi, \rho} \yields \state{3, \xi, \phi, \rho (x->3)}$ 

Formal Var - $\state{VAR(x), \xi, \phi, \rho' (x->3)} \yields \state{3, \xi, \phi, \rho' (x ->3)}$

----  
$\state{BEGIN (SET (x, LIT 3), VAR(x)), \xi, \phi, \rho} \yields \state{3, \xi', \phi, \rho' (x-> 3)}$

## Problem 14 {-}
$\state{IF (VAR(x), VAR(x), LIT 0), \xi, \phi, \rho} \yields \state{V, \xi', \phi, \rho'}$

$\state{VAR(x), \xi, \phi, \rho} \yields \state{V2, \xi'', \phi, \rho''}$

If false both V1 and the resulting V2 are 0. If true Var x is returned which results in Var x = Var x

If False: 

$\state{VAR(x), \xi, \phi, \rho} \state{V1, \xi', \phi, \rho'}$
$,V1 = 0,$
$\state{LIT 0, \xi', \phi, \rho'} \yields \state{0, \xi'', \phi, \rho''}$

If True: 

$\state{VAR(x), \xi, \phi, \rho} \yields \state{V1, \xi', \phi, \rho'}$
$,V1 =/= 0,$
$\state{VAR x, \xi', \phi, \rho'} \yields \state{V2, \xi', \phi, \rho''}$

---------
$\state{IF (VAR(x), VAR(x), LIT 0), \xi, \phi, \rho} \yields \state{V2, \xi', \phi, \rho'}$
## Problem 23 {-}


LITERAL 

$\state{LIT(v), \xi, \phi, \rho} \yields \state{v, \xi, \phi, \rho}$

We can evaluate the literal without touching the stack

FORMAL VAR 

$\inference%
  {x \in @dom \rho}%
  {\state{VAR(x), \xi, \phi, \rho} \yields \state{\rho(x), \xi, \phi, \rho}}$

We can pop $\rho$ off the stack and see if x exists within domain $\rho$. We then push $\rho$ back onto the stack

FORMAL ASSIGN

$\inference%
  {x \in @dom \rho,    \state{e, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'}}%
  {\state{SET(x,e), \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'x -> v}}$

Pop $\rho$ off the stack and check to see if x exists within the domain. Then use the inductive hypothesis to evaluate $\state{e, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'}$ which will pop and push $\rho$ and $\rho'$
Now we can pop $\rho'$, and push the resulting environment $\rho' (x -> v)$

GLOBAL VAR

$\inference%
  {x \notin @dom \rho,  x \in @dom \xi}%
  {\state{VAR(x), \xi, \phi, \rho} \yields \state{\xi(x), \xi, \phi, \rho}}$

By popping $\rho$ and seeing that x does not exist within domain $\rho$. Then we perform the evaluation and then push $\rho$ back onto the stack

EMPTY BEGIN

$\state{BEGIN(), \xi, \phi, \rho} \yields \state{0, \xi, \phi, \rho}$

Can be implemented without looking at an environment or touching the stack

BEGIN

$\state{e1, \xi, \phi, \rho} \yields \state{v1, \xi', \phi, \rho'}$ 

$\state{e2, \xi, \phi, \rho} \yields \state{v2, \xi'', \phi, \rho''}$ 

$\state{en, \xi, \phi, \rho} \yields \state{vn, \xi n, \phi, \rho n}$ 

----

$ \state{BEGIN(e1, e2, .... en), \xi 0, \phi, \rho 0} \yields \state{vn, \xi n, \phi, \rho n}$

Evaluate each expression e1, e2, . . . , en using the inductive hypothes.
For each expression e, the implementation pops e and then pushes the next e. 

GLOBAL ASSIGN

$\inference%
  {x \notin @dom \rho, x \in @dom \xi   \state{e, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'}}%
  {\state{SET(x, e), \xi, \phi, \rho} \yields \state{v, \xi' x ->v, \phi, \rho'}}$

We need to check to see that x does not exist within domain $\rho$. We do this by popping $\rho$ and then pushing it back onto the stack.
Next, using the induction hypothesis we can evaluate $\state{e, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'}$ using a stack. This evaluation will pop $\rho$ and push $\rho'$

IFTRUE

$\inference%
  {\state{e1, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'}  V1 != 0  \state{e2, \xi', \phi, \rho'} \yields \state{v2, \xi'', \phi, \rho''}}%
  {\state{IF(e1, e2, e3), \xi, \phi, \rho} \yields \state{v3, \xi'' x ->v, \phi, \rho''}}$

Use the induction hypothesis to evaluate $\state{e1, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'}$. Doing this will pop $\rho$ and push $\rho'$ onto the stack. 
We can use the induction hypothesis again to show that evaluating e2 can pop $\rho'$, push $\rho''$ 
When e1 evaluates to a nonzero value we can evaluate IF(e1, e2, e3) which pops and pushes $\rho''$

IFFALSE

$\inference%
  {\state{e1, \xi, \phi, \rho} \yields \state{v, \xi', \phi, \rho'}  V1 = 0  \state{e3, \xi', \phi, \rho'} \yields \state{v3, \xi'', \phi, \rho''}}%
  {\state{IF(e1, e2, e3), \xi, \phi, \rho} \yields \state{v3, \xi'' x ->v, \phi, \rho''}}$

Holds true for the answer above.

APPLY ADD

$\state{e1, \xi 0, \phi, \rho 0} \yields \state{v1, \xi 1, \phi, \rho 1}$ 

$\state{e2, \xi 1, \phi, \rho 1} \yields \state{v2, \xi 2, \phi, \rho 2}$

----
$\state{APPLY(f, e1, e2), \xi 0, \phi, \rho 0} \yields \state{v1 + v2, \xi 2, \phi, \rho 2}$

By the induction hypothesis, we can evaluate e1 and e2 using a stack. Doing this for each iteration will pop $\rho 0$ and push $\rho 2$

WHILEITERATE

$\state{e1, \xi, \phi, \rho} \yields \state{v1, \xi', \phi, \rho'}  v1 != 0$

$\state{e2, \xi', \phi, \rho'} \yields \state{v2, \xi'', \phi, \rho''} \state{WHILE(e1, e2), \xi'', \phi, \rho''} \yields \state{v3, \xi''', \phi, \rho'''}$

----
$\state{WHILE(e1, e2), \xi, \phi, \rho} \yields \state{v3, \xi''', \phi, \rho'''}$

Using the induction hypothesis we evaluate $\state{e1, \xi, \phi, \rho} \yields \state{v1, \xi', \phi, \rho'}$,
and the evaluation will pop $\rho$ and push $\rho'$. We can do the same when evaluating $\state{e2, \xi', \phi, \rho'} \yields \state{v2, \xi'', \phi, \rho''}$ using a stack, popping
$\rho'$ and pushing $\rho''$. We can do this for each subsequent version of $\rho$ environments 

WHILEEND

$\inference%
  {\state{e1, \xi, \phi, \rho} \yields \state{v1, \xi', \phi, \rho'}  v1 = 0}%
  {\state{WHILE(e1, e2), \xi, \phi, \rho} \yields \state{0, \xi', \phi, \rho'}}$

Using the induction hypothesis we evaluate $\state{e1, \xi, \phi, \rho} \yields \state{v1, \xi', \phi, \rho'}$ using a stack,
and the evaluation will pop $\rho$ and push $\rho''$. 
This implementation does not need a stack or to interact with an environment after this.